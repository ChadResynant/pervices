#!/usr/bin/env python3
"""
Acode Parser for OpenVNMRJ→Crimson TNG Bridge
Parses binary Acode files generated by PSG compiler

Author: Resynant, Inc.
Date: November 2025
"""

import struct
from typing import Dict, List, Optional
from enum import IntEnum


class AcodeOp(IntEnum):
    """Acode opcodes from nvpsg/acodes.h"""
    NO_OP = 0
    CBEGIN = 1
    EXIT = 2
    HALT = 4
    CLEAR = 5
    APBOUT = 6
    EVENT = 10
    INIT = 19
    BRANCH = 20
    INITDELAY = 21
    INCRDELAY = 22
    RAMODE = 23
    PHASESHIFT = 25
    acqstart = 44
    acqend = 45
    EVENT1 = 46
    EVENT2 = 47
    initstm = 48
    RT_EVENT1 = 51
    CHKHDWARE = 54
    LOADF = 55
    INITFREQ = 57
    INCRFREQ = 58


class AcodeParser:
    """
    Parse binary Acode files generated by OpenVNMRJ PSG compiler.

    The Acode format is a sequence of integer opcodes followed by
    opcode-specific parameters. This parser reads the binary file
    and converts it to a list of Python dictionaries for processing
    by the Crimson bridge.
    """

    def __init__(self, acode_file_path: str):
        """
        Initialize parser with path to Acode file.

        Args:
            acode_file_path: Path to binary Acode file
        """
        self.file_path = acode_file_path
        self.acode_data: Optional[bytes] = None
        self.pc = 0  # Program counter (byte position)
        self.acodes: List[Dict] = []

    def load_file(self) -> None:
        """Read binary Acode file into memory."""
        try:
            with open(self.file_path, 'rb') as f:
                self.acode_data = f.read()
            print(f"Loaded Acode file: {len(self.acode_data)} bytes")
        except FileNotFoundError:
            raise FileNotFoundError(f"Acode file not found: {self.file_path}")
        except Exception as e:
            raise RuntimeError(f"Error reading Acode file: {e}")

    def read_int32(self) -> int:
        """Read 32-bit big-endian integer at current position."""
        if self.pc + 4 > len(self.acode_data):
            raise EOFError("Unexpected end of Acode data")

        value = struct.unpack('>I', self.acode_data[self.pc:self.pc+4])[0]
        self.pc += 4
        return value

    def read_int64(self) -> int:
        """Read 64-bit big-endian integer at current position."""
        if self.pc + 8 > len(self.acode_data):
            raise EOFError("Unexpected end of Acode data")

        value = struct.unpack('>Q', self.acode_data[self.pc:self.pc+8])[0]
        self.pc += 8
        return value

    def parse_event1(self) -> Dict:
        """
        Parse EVENT1 opcode.

        Format: EVENT1 <timing_word> <gate_pattern>
        Used for pulses, delays, gate control.
        """
        timing = self.read_int32()
        gates = self.read_int32()

        return {
            'opcode': 'EVENT1',
            'timing': timing,  # Duration in hardware ticks
            'gates': gates,    # Bit pattern for which gates/channels active
            'duration_us': timing / 80.0  # Assuming 80 MHz clock (12.5 ns tick)
        }

    def parse_event2(self) -> Dict:
        """
        Parse EVENT2 opcode.

        Format: EVENT2 <timing_word1> <gate_pattern> <timing_word2>
        Higher precision timing (two words).
        """
        timing1 = self.read_int32()
        gates = self.read_int32()
        timing2 = self.read_int32()

        # Combine two timing words for higher precision
        total_timing = (timing1 << 32) | timing2

        return {
            'opcode': 'EVENT2',
            'timing': total_timing,
            'gates': gates,
            'duration_us': total_timing / 80.0
        }

    def parse_initfreq(self) -> Dict:
        """
        Parse INITFREQ opcode.

        Format: INITFREQ <channel> <frequency>
        Set RF carrier frequency for a channel.
        """
        channel = self.read_int32()
        freq = self.read_int64()  # Frequency in Hz

        return {
            'opcode': 'INITFREQ',
            'channel': channel,
            'frequency': freq
        }

    def parse_incrfreq(self) -> Dict:
        """
        Parse INCRFREQ opcode.

        Format: INCRFREQ <channel> <increment>
        Increment RF frequency (for sweeps).
        """
        channel = self.read_int32()
        increment = self.read_int32()

        return {
            'opcode': 'INCRFREQ',
            'channel': channel,
            'increment': increment
        }

    def parse_phaseshift(self) -> Dict:
        """
        Parse PHASESHIFT opcode.

        Format: PHASESHIFT <channel> <phase>
        Set transmitter phase.
        """
        channel = self.read_int32()
        phase = self.read_int32()  # Phase in 90° increments (0=0°, 1=90°, 2=180°, 3=270°)

        return {
            'opcode': 'PHASESHIFT',
            'channel': channel,
            'phase_degrees': phase * 90
        }

    def parse_acqstart(self) -> Dict:
        """
        Parse acqstart opcode.

        Format: acqstart
        Begin data acquisition.
        """
        return {
            'opcode': 'acqstart'
        }

    def parse_acqend(self) -> Dict:
        """
        Parse acqend opcode.

        Format: acqend
        End data acquisition.
        """
        return {
            'opcode': 'acqend'
        }

    def parse_halt(self) -> Dict:
        """
        Parse HALT opcode.

        Format: HALT
        Stop sequence execution.
        """
        return {
            'opcode': 'HALT'
        }

    def parse_branch(self) -> Dict:
        """
        Parse BRANCH opcode.

        Format: BRANCH <offset>
        Branch to new position (for loops).
        """
        offset = self.read_int32()

        return {
            'opcode': 'BRANCH',
            'offset': offset
        }

    def parse_next_acode(self) -> Optional[Dict]:
        """
        Parse next Acode from buffer.

        Returns:
            Dictionary with opcode and parameters, or None if end of file
        """
        if self.pc >= len(self.acode_data):
            return None

        # Read opcode
        try:
            opcode = self.read_int32()
        except EOFError:
            return None

        # Parse opcode-specific parameters
        try:
            if opcode == AcodeOp.EVENT1:
                return self.parse_event1()
            elif opcode == AcodeOp.EVENT2:
                return self.parse_event2()
            elif opcode == AcodeOp.INITFREQ:
                return self.parse_initfreq()
            elif opcode == AcodeOp.INCRFREQ:
                return self.parse_incrfreq()
            elif opcode == AcodeOp.PHASESHIFT:
                return self.parse_phaseshift()
            elif opcode == AcodeOp.acqstart:
                return self.parse_acqstart()
            elif opcode == AcodeOp.acqend:
                return self.parse_acqend()
            elif opcode == AcodeOp.HALT:
                return self.parse_halt()
            elif opcode == AcodeOp.BRANCH:
                return self.parse_branch()
            elif opcode == AcodeOp.NO_OP:
                return {'opcode': 'NO_OP'}
            else:
                # Unknown opcode - record and skip
                print(f"WARNING: Unknown opcode {opcode} at position {self.pc-4}")
                return {'opcode': 'UNKNOWN', 'code': opcode}

        except EOFError:
            print(f"ERROR: Unexpected end of data while parsing opcode {opcode}")
            return None

    def parse_all(self) -> List[Dict]:
        """
        Parse all Acodes from file.

        Returns:
            List of Acode dictionaries
        """
        if self.acode_data is None:
            self.load_file()

        self.pc = 0
        self.acodes = []

        while True:
            acode = self.parse_next_acode()
            if acode is None:
                break
            self.acodes.append(acode)

            # Stop at HALT
            if acode.get('opcode') == 'HALT':
                break

        print(f"Parsed {len(self.acodes)} Acodes")
        return self.acodes

    def print_acodes(self) -> None:
        """Print human-readable Acode list."""
        if not self.acodes:
            self.parse_all()

        print("\nAcode Listing:")
        print("=" * 80)

        for i, acode in enumerate(self.acodes):
            opcode = acode['opcode']

            if opcode == 'EVENT1':
                print(f"{i:4d}: EVENT1    time={acode['duration_us']:.3f} us  gates=0x{acode['gates']:08X}")

            elif opcode == 'EVENT2':
                print(f"{i:4d}: EVENT2    time={acode['duration_us']:.3f} us  gates=0x{acode['gates']:08X}")

            elif opcode == 'INITFREQ':
                print(f"{i:4d}: INITFREQ  ch={acode['channel']}  freq={acode['frequency']/1e6:.3f} MHz")

            elif opcode == 'PHASESHIFT':
                print(f"{i:4d}: PHASESHIFT ch={acode['channel']}  phase={acode['phase_degrees']}°")

            elif opcode == 'acqstart':
                print(f"{i:4d}: acqstart")

            elif opcode == 'acqend':
                print(f"{i:4d}: acqend")

            elif opcode == 'HALT':
                print(f"{i:4d}: HALT")

            elif opcode == 'BRANCH':
                print(f"{i:4d}: BRANCH    offset={acode['offset']}")

            else:
                print(f"{i:4d}: {opcode}")

        print("=" * 80)


# Test harness
if __name__ == '__main__':
    import sys

    if len(sys.argv) < 2:
        print("Usage: python acode_parser.py <acode_file>")
        print("\nExample: python acode_parser.py /vnmr/acqqueue/acodes")
        sys.exit(1)

    acode_file = sys.argv[1]

    print("Acode Parser for OpenVNMRJ → Crimson TNG Bridge")
    print("=" * 80)
    print(f"Parsing: {acode_file}\n")

    parser = AcodeParser(acode_file)
    parser.parse_all()
    parser.print_acodes()

    print(f"\nTotal Acodes: {len(parser.acodes)}")
