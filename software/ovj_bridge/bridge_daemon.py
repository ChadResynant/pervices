#!/usr/bin/env python3
"""
OpenVNMRJ to Crimson TNG Bridge Daemon

Monitors OpenVNMRJ experiment directories for PSG compilation completion,
loads compiled Acode files, and translates them to Crimson TNG commands.

Architecture:
    PSG Compiler → Acode files → Bridge Daemon → Crimson TNG

Key Functions:
    - Watch {curexp}/psgdone for PSG completion signal
    - Read goid parameter to locate Acode files
    - Parse multiple controller Acode files (Master1, RF1, RF2, etc.)
    - Coordinate multi-channel execution on Crimson TNG

Author: Chad Rienstra / Claude Code
Date: November 21, 2025
"""

import os
import sys
import time
import glob
import logging
from typing import List, Dict, Optional
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from acode_parser import AcodeParser
from pulse_generator import PulseGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class VnmrJParameterReader:
    """Read parameters from OpenVNMRJ experiment directories."""

    def __init__(self, curexp: str):
        """
        Initialize parameter reader.

        Args:
            curexp: Current experiment directory (e.g., "/vnmr/exp1")
        """
        self.curexp = curexp
        self.curpar_file = os.path.join(curexp, "curpar")

    def read_parameter(self, param_name: str) -> Optional[str]:
        """
        Read a parameter value from curpar file.

        VnmrJ stores parameters in a text file format:
            param_name value_count value_type
            value1
            value2
            ...

        Args:
            param_name: Parameter name (e.g., "goid", "acqcycles")

        Returns:
            Parameter value as string, or None if not found
        """
        if not os.path.exists(self.curpar_file):
            logger.warning(f"Parameter file not found: {self.curpar_file}")
            return None

        try:
            with open(self.curpar_file, 'r') as f:
                lines = f.readlines()

            # Search for parameter name
            for i, line in enumerate(lines):
                if line.startswith(param_name + ' '):
                    # Next line contains the value
                    if i + 1 < len(lines):
                        value = lines[i + 1].strip().strip('"')
                        return value

            logger.warning(f"Parameter '{param_name}' not found in {self.curpar_file}")
            return None

        except Exception as e:
            logger.error(f"Error reading parameter '{param_name}': {e}")
            return None


class AcodeFileLocator:
    """Locate Acode files generated by PSG compiler."""

    @staticmethod
    def get_acode_files(goid: str, stage: str = "ps") -> List[str]:
        """
        Find all Acode files for a given goid and stage.

        Acode files follow pattern: {goid}.{stage}.{controller}
        Example: /vnmrsystem/acqqueue/exp1.greg.012345.ps.RF1

        Args:
            goid: Base path from VnmrJ goid parameter
            stage: Acode stage (default: "ps" for pulse sequence)

        Returns:
            List of Acode file paths, sorted alphabetically
        """
        pattern = f"{goid}.{stage}.*"
        acode_files = glob.glob(pattern)

        # Filter out non-Acode files (e.g., .Code.lock files)
        acode_files = [f for f in acode_files if not f.endswith('.lock')]

        return sorted(acode_files)

    @staticmethod
    def extract_controller_name(filepath: str) -> str:
        """
        Extract controller name from Acode file path.

        Example:
            /vnmrsystem/acqqueue/exp1.greg.012345.ps.RF1 → RF1

        Args:
            filepath: Full path to Acode file

        Returns:
            Controller name (e.g., "Master1", "RF1", "RF2")
        """
        basename = os.path.basename(filepath)
        parts = basename.split('.')

        # Controller name is the last component
        if len(parts) >= 3:
            return parts[-1]
        else:
            logger.warning(f"Unexpected Acode filename format: {filepath}")
            return "Unknown"


class PSGCompletionHandler(FileSystemEventHandler):
    """
    Watchdog event handler for monitoring PSG compilation completion.

    Watches for creation of {curexp}/psgdone file, which signals that
    PSG has finished compiling the pulse sequence to Acode files.
    """

    def __init__(self, bridge):
        """
        Initialize handler.

        Args:
            bridge: AcodeBridge instance to notify on PSG completion
        """
        self.bridge = bridge
        super().__init__()

    def on_created(self, event):
        """
        Handle file creation events.

        Args:
            event: Watchdog file system event
        """
        if not event.is_directory and event.src_path.endswith('/psgdone'):
            logger.info(f"PSG completion detected: {event.src_path}")

            # Extract experiment directory
            curexp = os.path.dirname(event.src_path)

            # Notify bridge to load and execute sequence
            self.bridge.on_psg_complete(curexp)


class AcodeBridge:
    """
    Main bridge between OpenVNMRJ PSG compiler and Crimson TNG hardware.

    Responsibilities:
        1. Monitor for PSG completion (psgdone file)
        2. Locate and load Acode files
        3. Parse Acode opcodes
        4. Translate to Crimson TNG commands
        5. Coordinate multi-channel execution
    """

    def __init__(self, watch_dirs: List[str], crimson_api=None):
        """
        Initialize bridge daemon.

        Args:
            watch_dirs: List of experiment directories to monitor (e.g., ["/vnmr/exp1", "/vnmr/exp2"])
            crimson_api: Crimson TNG API wrapper (optional, for testing can be None)
        """
        self.watch_dirs = watch_dirs
        self.crimson_api = crimson_api
        self.observers = []
        self.parsers = {}  # {controller_name: AcodeParser}
        self.pulse_generator = PulseGenerator(sample_rate=325e6)

    def start(self):
        """
        Start monitoring experiment directories for PSG completion.

        Sets up watchdog observers for each experiment directory.
        """
        logger.info(f"Starting Acode bridge daemon")
        logger.info(f"Monitoring directories: {self.watch_dirs}")

        event_handler = PSGCompletionHandler(self)

        for watch_dir in self.watch_dirs:
            if not os.path.exists(watch_dir):
                logger.warning(f"Watch directory does not exist: {watch_dir}")
                continue

            observer = Observer()
            observer.schedule(event_handler, watch_dir, recursive=False)
            observer.start()
            self.observers.append(observer)
            logger.info(f"Monitoring: {watch_dir}")

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        """Stop all file system observers."""
        logger.info("Stopping Acode bridge daemon")
        for observer in self.observers:
            observer.stop()
            observer.join()

    def on_psg_complete(self, curexp: str):
        """
        Handle PSG compilation completion.

        Called when psgdone file is created in experiment directory.

        Args:
            curexp: Experiment directory path (e.g., "/vnmr/exp1")
        """
        logger.info(f"Processing PSG completion for: {curexp}")

        try:
            # Read goid parameter to locate Acode files
            param_reader = VnmrJParameterReader(curexp)
            goid = param_reader.read_parameter("goid")

            if goid is None:
                logger.error(f"Could not read goid parameter from {curexp}")
                return

            logger.info(f"goid: {goid}")

            # Locate all Acode files
            acode_files = AcodeFileLocator.get_acode_files(goid)

            if not acode_files:
                logger.warning(f"No Acode files found for goid: {goid}")
                return

            logger.info(f"Found {len(acode_files)} Acode file(s):")
            for filepath in acode_files:
                controller = AcodeFileLocator.extract_controller_name(filepath)
                logger.info(f"  {controller}: {filepath}")

            # Load and parse all Acode files
            self.load_sequence(acode_files)

            # Execute sequence on Crimson TNG
            self.execute_sequence()

        except Exception as e:
            logger.error(f"Error processing PSG completion: {e}", exc_info=True)

    def load_sequence(self, acode_files: List[str]):
        """
        Load and parse all Acode files for a sequence.

        Args:
            acode_files: List of Acode file paths
        """
        self.parsers.clear()

        for filepath in acode_files:
            controller = AcodeFileLocator.extract_controller_name(filepath)

            try:
                # Create parser for this controller
                parser = AcodeParser(filepath)
                self.parsers[controller] = parser

                logger.info(f"Loaded Acode file for {controller}")

            except Exception as e:
                logger.error(f"Error loading Acode file {filepath}: {e}", exc_info=True)

    def execute_sequence(self):
        """
        Execute loaded sequence on Crimson TNG hardware.

        Coordinates multi-channel execution across all controllers.
        """
        if not self.parsers:
            logger.warning("No Acode parsers loaded, cannot execute sequence")
            return

        logger.info(f"Executing sequence with {len(self.parsers)} controller(s)")

        # Parse all Acode streams
        sequences = {}
        for controller, parser in self.parsers.items():
            try:
                logger.info(f"Parsing Acode stream for {controller}")
                opcodes = parser.parse_all()
                sequences[controller] = opcodes
                logger.info(f"  Parsed {len(opcodes)} opcode(s)")

            except Exception as e:
                logger.error(f"Error parsing Acode for {controller}: {e}", exc_info=True)
                continue

        # Translate Acode opcodes to Crimson TNG commands
        if self.crimson_api:
            try:
                self.crimson_api.execute_multi_channel(sequences)
                logger.info("Sequence execution started on Crimson TNG")
            except Exception as e:
                logger.error(f"Error executing on Crimson TNG: {e}", exc_info=True)
        else:
            logger.info("No Crimson API configured (dry-run mode)")
            logger.info("Sequence translation completed successfully")


def main():
    """
    Main entry point for bridge daemon.

    Usage:
        python bridge_daemon.py /vnmr/exp1 /vnmr/exp2 ...

    Or to monitor all standard experiments:
        python bridge_daemon.py /vnmr/exp{1..8}
    """
    import argparse

    parser = argparse.ArgumentParser(
        description='OpenVNMRJ to Crimson TNG Bridge Daemon',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    # Monitor a single experiment directory
    python bridge_daemon.py /vnmr/exp1

    # Monitor multiple experiments
    python bridge_daemon.py /vnmr/exp1 /vnmr/exp2 /vnmr/exp3

    # Dry-run mode (no Crimson TNG hardware)
    python bridge_daemon.py --dry-run /vnmr/exp1
        """
    )

    parser.add_argument(
        'watch_dirs',
        nargs='+',
        help='Experiment directories to monitor (e.g., /vnmr/exp1)'
    )

    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Run without Crimson TNG hardware (parsing only)'
    )

    parser.add_argument(
        '--log-level',
        choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
        default='INFO',
        help='Logging level (default: INFO)'
    )

    args = parser.parse_args()

    # Set log level
    logging.getLogger().setLevel(getattr(logging, args.log_level))

    # Initialize Crimson API (if not dry-run)
    crimson_api = None
    if not args.dry_run:
        # TODO: Import and initialize Crimson TNG API
        # from crimson_api import CrimsonAPI
        # crimson_api = CrimsonAPI(host='192.168.1.10')
        logger.warning("Crimson API not yet implemented, running in dry-run mode")

    # Create and start bridge
    bridge = AcodeBridge(watch_dirs=args.watch_dirs, crimson_api=crimson_api)
    bridge.start()


if __name__ == '__main__':
    main()
